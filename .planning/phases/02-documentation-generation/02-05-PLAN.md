---
phase: 02-documentation-generation
plan: 05
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/generation/writers/supplementary.ts
  - src/generation/complexity.ts
autonomous: true

must_haves:
  truths:
    - "ARCHITECTURE.md generated when complexity thresholds exceeded"
    - "STACK.md generated from package.json dependencies"
    - "Complexity detection identifies architectural patterns"
    - "Supplementary docs location configurable (root or .docs/)"
  artifacts:
    - path: "src/generation/writers/supplementary.ts"
      provides: "ARCHITECTURE.md and STACK.md writers"
      exports: ["writeArchitectureMd", "writeStackMd", "SupplementaryConfig"]
    - path: "src/generation/complexity.ts"
      provides: "Complexity detection for supplementary doc triggers"
      exports: ["analyzeComplexity", "shouldGenerateArchitecture", "ComplexityMetrics"]
  key_links:
    - from: "src/generation/writers/supplementary.ts"
      to: "src/generation/complexity.ts"
      via: "uses shouldGenerateArchitecture to decide generation"
      pattern: "import.*complexity"
---

<objective>
Create supplementary documentation generators (ARCHITECTURE.md, STACK.md) and complexity detection.

Purpose: Large or complex codebases benefit from architectural overview and stack documentation. ARCHITECTURE.md provides structural understanding, STACK.md documents dependencies and technology choices. These are generated conditionally based on complexity thresholds.

Output: Complexity analyzer and supplementary doc writers that generate content-driven documentation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-documentation-generation/02-CONTEXT.md
@.planning/phases/02-documentation-generation/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create complexity analyzer</name>
  <files>src/generation/complexity.ts</files>
  <action>
Create src/generation/complexity.ts for analyzing codebase complexity:

```typescript
import path from 'node:path';

/**
 * Metrics about codebase complexity.
 */
export interface ComplexityMetrics {
  /** Total number of source files */
  fileCount: number;
  /** Maximum directory depth */
  directoryDepth: number;
  /** Detected architectural patterns */
  architecturalPatterns: string[];
  /** List of source file paths */
  files: string[];
  /** Unique directory paths */
  directories: Set<string>;
}

/**
 * Architectural pattern definitions with detection heuristics.
 */
const PATTERN_DETECTORS: Array<{
  name: string;
  indicators: string[];
  minMatches: number;
}> = [
  {
    name: 'layered-architecture',
    indicators: ['controllers/', 'services/', 'repositories/', 'dao/'],
    minMatches: 2,
  },
  {
    name: 'clean-architecture',
    indicators: ['domain/', 'application/', 'infrastructure/', 'usecases/'],
    minMatches: 2,
  },
  {
    name: 'nextjs-convention',
    indicators: ['/api/', '/pages/', '/app/', 'middleware.'],
    minMatches: 2,
  },
  {
    name: 'presentational-container',
    indicators: ['components/', 'containers/', 'views/'],
    minMatches: 2,
  },
  {
    name: 'redux-pattern',
    indicators: ['redux/', 'store/', 'slices/', 'reducers/', 'actions/'],
    minMatches: 2,
  },
  {
    name: 'react-patterns',
    indicators: ['hooks/', 'context/', 'providers/'],
    minMatches: 2,
  },
  {
    name: 'microservices',
    indicators: ['services/', 'gateway/', 'shared/', 'common/', 'packages/'],
    minMatches: 3,
  },
  {
    name: 'feature-based',
    indicators: ['features/', 'modules/', 'domains/'],
    minMatches: 1,
  },
  {
    name: 'mvc-pattern',
    indicators: ['models/', 'views/', 'controllers/'],
    minMatches: 3,
  },
];

/**
 * Detect architectural patterns from file paths.
 */
function detectArchitecturalPatterns(files: string[]): string[] {
  const patterns: string[] = [];
  const normalizedFiles = files.map(f => f.toLowerCase().replace(/\\/g, '/'));

  for (const detector of PATTERN_DETECTORS) {
    const matches = detector.indicators.filter(indicator =>
      normalizedFiles.some(f => f.includes(indicator))
    );

    if (matches.length >= detector.minMatches) {
      patterns.push(detector.name);
    }
  }

  return patterns;
}

/**
 * Calculate maximum directory depth from file paths.
 */
function calculateDirectoryDepth(files: string[], projectRoot: string): number {
  let maxDepth = 0;

  for (const file of files) {
    const relativePath = path.relative(projectRoot, file);
    const depth = relativePath.split(path.sep).length - 1; // -1 for the file itself
    maxDepth = Math.max(maxDepth, depth);
  }

  return maxDepth;
}

/**
 * Extract unique directories from file paths.
 */
function extractDirectories(files: string[]): Set<string> {
  const directories = new Set<string>();

  for (const file of files) {
    let dir = path.dirname(file);
    while (dir && dir !== '.') {
      directories.add(dir);
      const parent = path.dirname(dir);
      if (parent === dir) break; // Reached root
      dir = parent;
    }
  }

  return directories;
}

/**
 * Analyze codebase complexity from discovered files.
 *
 * @param files - List of source file paths
 * @param projectRoot - Project root directory
 * @returns Complexity metrics
 */
export function analyzeComplexity(
  files: string[],
  projectRoot: string
): ComplexityMetrics {
  return {
    fileCount: files.length,
    directoryDepth: calculateDirectoryDepth(files, projectRoot),
    architecturalPatterns: detectArchitecturalPatterns(files),
    files,
    directories: extractDirectories(files),
  };
}

/**
 * Determine if ARCHITECTURE.md should be generated.
 *
 * Triggers (any one fires):
 * - 20+ source files
 * - 3+ directory levels
 * - Multiple architectural patterns detected
 */
export function shouldGenerateArchitecture(metrics: ComplexityMetrics): boolean {
  // Threshold: 20+ source files
  if (metrics.fileCount >= 20) return true;

  // Threshold: 3+ directory levels
  if (metrics.directoryDepth >= 3) return true;

  // Threshold: 2+ architectural patterns
  if (metrics.architecturalPatterns.length >= 2) return true;

  return false;
}

/**
 * Determine if STACK.md should be generated.
 *
 * Always generate if package.json exists (has dependencies to document).
 */
export function shouldGenerateStack(hasPackageJson: boolean): boolean {
  return hasPackageJson;
}

/**
 * Generate a summary of why supplementary docs should/shouldn't be generated.
 */
export function getComplexitySummary(metrics: ComplexityMetrics): string {
  const lines = [
    `Files: ${metrics.fileCount}`,
    `Directory depth: ${metrics.directoryDepth}`,
    `Patterns detected: ${metrics.architecturalPatterns.length > 0 ? metrics.architecturalPatterns.join(', ') : 'none'}`,
  ];

  if (shouldGenerateArchitecture(metrics)) {
    lines.push('ARCHITECTURE.md: will be generated');
  } else {
    lines.push('ARCHITECTURE.md: not needed (below thresholds)');
  }

  return lines.join('\n');
}
```
  </action>
  <verify>npx tsc --noEmit src/generation/complexity.ts</verify>
  <done>Complexity module exports analyzeComplexity, shouldGenerateArchitecture, shouldGenerateStack, ComplexityMetrics</done>
</task>

<task type="auto">
  <name>Task 2: Create supplementary doc writers</name>
  <files>src/generation/writers/supplementary.ts</files>
  <action>
Create src/generation/writers/supplementary.ts for ARCHITECTURE.md and STACK.md:

```typescript
import { writeFile, readFile, mkdir } from 'node:fs/promises';
import path from 'node:path';
import type { ComplexityMetrics } from '../complexity.js';

/**
 * Configuration for supplementary documentation.
 */
export interface SupplementaryConfig {
  /** Output directory (default: project root) */
  outputDir?: string;
  /** Whether to generate ARCHITECTURE.md */
  generateArchitecture: boolean;
  /** Whether to generate STACK.md */
  generateStack: boolean;
}

/**
 * Information about the technology stack.
 */
export interface StackInfo {
  /** Runtime environment */
  runtime: string;
  /** Primary framework */
  framework?: string;
  /** Key dependencies grouped by category */
  dependencies: Record<string, Array<{ name: string; version: string; purpose?: string }>>;
  /** Development tools */
  devTools: string[];
}

/**
 * Build ARCHITECTURE.md content from complexity metrics.
 *
 * This generates a template that the host LLM will expand with actual
 * architectural analysis.
 */
export function buildArchitectureMd(
  metrics: ComplexityMetrics,
  projectName: string
): string {
  const sections: string[] = [];

  // Header
  sections.push(`# Architecture: ${projectName}\n`);
  sections.push(`> Auto-generated architecture overview. ${metrics.fileCount} files analyzed.\n`);

  // Detected patterns
  if (metrics.architecturalPatterns.length > 0) {
    sections.push('## Architectural Patterns\n');
    for (const pattern of metrics.architecturalPatterns) {
      sections.push(`- **${formatPatternName(pattern)}**`);
    }
    sections.push('');
  }

  // Directory structure (high-level)
  sections.push('## Directory Structure\n');
  sections.push('```');
  const topLevelDirs = getTopLevelDirectories(metrics.directories);
  for (const dir of topLevelDirs.sort()) {
    sections.push(`${dir}/`);
  }
  sections.push('```\n');

  // Layers section (placeholder for LLM expansion)
  sections.push('## Layers\n');
  sections.push('<!-- This section describes the architectural layers -->\n');

  // Data flow section (placeholder)
  sections.push('## Data Flow\n');
  sections.push('<!-- This section describes how data flows through the system -->\n');

  // Key abstractions (placeholder)
  sections.push('## Key Abstractions\n');
  sections.push('<!-- This section describes important interfaces and patterns -->\n');

  return sections.join('\n');
}

/**
 * Format pattern name for display.
 */
function formatPatternName(pattern: string): string {
  return pattern
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

/**
 * Get top-level directories from all directories.
 */
function getTopLevelDirectories(directories: Set<string>): string[] {
  const topLevel: string[] = [];

  for (const dir of directories) {
    const parts = dir.split(path.sep);
    if (parts.length === 1 || (parts.length === 2 && parts[0] === '.')) {
      topLevel.push(parts[parts.length - 1]);
    }
  }

  return [...new Set(topLevel)];
}

/**
 * Build STACK.md content from package.json analysis.
 */
export function buildStackMd(
  stackInfo: StackInfo,
  projectName: string
): string {
  const sections: string[] = [];

  // Header
  sections.push(`# Technology Stack: ${projectName}\n`);

  // Runtime
  sections.push('## Runtime\n');
  sections.push(`- **Environment**: ${stackInfo.runtime}`);
  if (stackInfo.framework) {
    sections.push(`- **Framework**: ${stackInfo.framework}`);
  }
  sections.push('');

  // Dependencies by category
  for (const [category, deps] of Object.entries(stackInfo.dependencies)) {
    if (deps.length === 0) continue;

    sections.push(`## ${category}\n`);
    for (const dep of deps) {
      const purpose = dep.purpose ? ` - ${dep.purpose}` : '';
      sections.push(`- **${dep.name}** (${dep.version})${purpose}`);
    }
    sections.push('');
  }

  // Dev tools
  if (stackInfo.devTools.length > 0) {
    sections.push('## Development Tools\n');
    for (const tool of stackInfo.devTools) {
      sections.push(`- ${tool}`);
    }
    sections.push('');
  }

  return sections.join('\n');
}

/**
 * Parse package.json to extract stack information.
 */
export async function analyzePackageJson(
  packageJsonPath: string
): Promise<StackInfo | null> {
  try {
    const content = await readFile(packageJsonPath, 'utf-8');
    const pkg = JSON.parse(content);

    const stackInfo: StackInfo = {
      runtime: 'Node.js',
      dependencies: {
        'Core': [],
        'Framework': [],
        'Database': [],
        'Testing': [],
        'Build Tools': [],
        'Other': [],
      },
      devTools: [],
    };

    // Detect framework
    const frameworkDeps = ['next', 'react', 'vue', 'angular', 'svelte', 'express', 'fastify', 'nestjs'];
    const deps = { ...pkg.dependencies, ...pkg.devDependencies };

    for (const fw of frameworkDeps) {
      if (deps[fw]) {
        stackInfo.framework = fw.charAt(0).toUpperCase() + fw.slice(1);
        break;
      }
    }

    // Categorize dependencies
    const categoryRules: Array<{ category: string; patterns: string[] }> = [
      { category: 'Framework', patterns: ['react', 'vue', 'angular', 'svelte', 'next', 'nuxt', 'express', 'fastify', 'nestjs'] },
      { category: 'Database', patterns: ['prisma', 'mongoose', 'typeorm', 'sequelize', 'pg', 'mysql', 'redis', 'drizzle'] },
      { category: 'Testing', patterns: ['jest', 'vitest', 'mocha', 'chai', 'cypress', 'playwright', '@testing-library'] },
      { category: 'Build Tools', patterns: ['typescript', 'esbuild', 'vite', 'webpack', 'rollup', 'parcel', 'tsup'] },
    ];

    for (const [name, version] of Object.entries(pkg.dependencies ?? {})) {
      let categorized = false;
      for (const rule of categoryRules) {
        if (rule.patterns.some(p => name.toLowerCase().includes(p))) {
          stackInfo.dependencies[rule.category].push({ name, version: version as string });
          categorized = true;
          break;
        }
      }
      if (!categorized) {
        stackInfo.dependencies['Other'].push({ name, version: version as string });
      }
    }

    // Dev tools
    const devToolPatterns = ['eslint', 'prettier', 'husky', 'lint-staged'];
    for (const [name] of Object.entries(pkg.devDependencies ?? {})) {
      if (devToolPatterns.some(p => name.includes(p))) {
        stackInfo.devTools.push(name);
      }
    }

    return stackInfo;
  } catch {
    return null;
  }
}

/**
 * Write ARCHITECTURE.md to the configured location.
 */
export async function writeArchitectureMd(
  projectRoot: string,
  metrics: ComplexityMetrics,
  config: SupplementaryConfig
): Promise<string | null> {
  if (!config.generateArchitecture) return null;

  const outputDir = config.outputDir
    ? path.join(projectRoot, config.outputDir)
    : projectRoot;

  await mkdir(outputDir, { recursive: true });

  const projectName = path.basename(projectRoot);
  const content = buildArchitectureMd(metrics, projectName);
  const filePath = path.join(outputDir, 'ARCHITECTURE.md');

  await writeFile(filePath, content, 'utf-8');
  return filePath;
}

/**
 * Write STACK.md to the configured location.
 */
export async function writeStackMd(
  projectRoot: string,
  config: SupplementaryConfig
): Promise<string | null> {
  if (!config.generateStack) return null;

  const packageJsonPath = path.join(projectRoot, 'package.json');
  const stackInfo = await analyzePackageJson(packageJsonPath);

  if (!stackInfo) return null;

  const outputDir = config.outputDir
    ? path.join(projectRoot, config.outputDir)
    : projectRoot;

  await mkdir(outputDir, { recursive: true });

  const projectName = path.basename(projectRoot);
  const content = buildStackMd(stackInfo, projectName);
  const filePath = path.join(outputDir, 'STACK.md');

  await writeFile(filePath, content, 'utf-8');
  return filePath;
}
```

Update src/generation/writers/index.ts to include supplementary exports:

```typescript
export {
  writeSumFile,
  readSumFile,
  getSumPath,
  sumFileExists,
  type SumFileContent,
} from './sum.js';

export {
  writeAgentsMd,
  buildAgentsMd,
  buildDirectoryDoc,
  type DirectoryDoc,
  type FileGroup,
  type FileRef,
  type SubdirSummary,
} from './agents-md.js';

export {
  writeClaudeMd,
  getClaudeMdContent,
} from './claude-md.js';

export {
  writeArchitectureMd,
  writeStackMd,
  buildArchitectureMd,
  buildStackMd,
  analyzePackageJson,
  type SupplementaryConfig,
  type StackInfo,
} from './supplementary.js';
```
  </action>
  <verify>npx tsc --noEmit src/generation/writers/supplementary.ts</verify>
  <done>Supplementary module exports writeArchitectureMd, writeStackMd, analyzePackageJson, SupplementaryConfig, StackInfo</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` - Full project compiles without errors
2. Verify complexity analysis works:
```typescript
import { analyzeComplexity, shouldGenerateArchitecture } from './src/generation/complexity.js';
const metrics = analyzeComplexity(['src/a.ts', 'src/b/c.ts'], '/project');
console.log(shouldGenerateArchitecture(metrics));
```
3. Verify supplementary writers are accessible
</verification>

<success_criteria>
- [ ] src/generation/complexity.ts exports analyzeComplexity, shouldGenerateArchitecture
- [ ] src/generation/writers/supplementary.ts exports writeArchitectureMd, writeStackMd
- [ ] ARCHITECTURE.md generation triggers at 20+ files OR 3+ depth OR 2+ patterns
- [ ] STACK.md parses package.json and categorizes dependencies
- [ ] Output location is configurable via SupplementaryConfig
</success_criteria>

<output>
After completion, create `.planning/phases/02-documentation-generation/02-05-SUMMARY.md`
</output>
