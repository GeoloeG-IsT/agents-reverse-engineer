---
phase: 02-documentation-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/generation/types.ts
  - src/generation/detection/detector.ts
  - src/generation/detection/patterns.ts
autonomous: true

must_haves:
  truths:
    - "File type detection returns correct type for files in standard directories"
    - "File type detection falls back to content analysis when directory is generic"
    - "All 11 file types are detectable (component, service, util, type, test, config, api, model, hook, schema, generic)"
  artifacts:
    - path: "src/generation/types.ts"
      provides: "Generation types and FileType enum"
      exports: ["FileType", "AnalysisRequest", "AnalysisResult", "SummaryMetadata"]
    - path: "src/generation/detection/detector.ts"
      provides: "File type detection logic"
      exports: ["detectFileType"]
    - path: "src/generation/detection/patterns.ts"
      provides: "Directory and content patterns"
      exports: ["DIRECTORY_PATTERNS", "detectFromContent"]
  key_links:
    - from: "src/generation/detection/detector.ts"
      to: "src/generation/detection/patterns.ts"
      via: "imports DIRECTORY_PATTERNS and detectFromContent"
      pattern: "import.*patterns"
---

<objective>
Create generation types and file type detection module for selecting appropriate prompt templates.

Purpose: File type detection enables file-type-specific prompts (component files get component prompts, hooks get hook prompts), which produces better quality summaries than generic prompts.

Output: Types for generation pipeline and detectFileType function that returns FileType based on directory path first, content patterns second.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-documentation-generation/02-CONTEXT.md
@.planning/phases/02-documentation-generation/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create generation types</name>
  <files>src/generation/types.ts</files>
  <action>
Create src/generation/types.ts with the following types:

```typescript
// FileType enum - 11 categories for template selection
export type FileType =
  | 'component'   // React/Vue/Svelte components
  | 'service'     // Business logic services
  | 'util'        // Utility functions
  | 'type'        // Type definitions only
  | 'test'        // Test files
  | 'config'      // Configuration files
  | 'api'         // API routes/handlers
  | 'model'       // Data models/entities
  | 'hook'        // React hooks
  | 'schema'      // Validation schemas (Zod, Yup, etc.)
  | 'generic';    // Fallback for undetected types

// Request to analyze a file
export interface AnalysisRequest {
  filePath: string;
  content: string;
  fileType: FileType;
  tokens: number;
  contextFiles?: string[];  // Related files for context
}

// Result of file analysis (populated by LLM via host)
export interface AnalysisResult {
  summary: string;
  metadata: SummaryMetadata;
}

// Metadata extracted during analysis
export interface SummaryMetadata {
  purpose: string;
  publicInterface: string[];
  dependencies: string[];
  patterns: string[];
  criticalTodos?: string[];  // Only security/breaking issues
  relatedFiles?: string[];   // Tightly coupled siblings
}

// Options for summary generation
export interface SummaryOptions {
  targetLength: 'short' | 'standard' | 'detailed';  // Maps to word counts
  includeCodeSnippets: boolean;
}

// Configuration for the generation process
export interface GenerationConfig {
  tokenBudget: number;
  outputDir?: string;  // For supplementary docs
  generateArchitecture: boolean;
  generateStack: boolean;
}
```

Export all types from the module. Follow the same patterns as src/types/index.ts from Phase 1.
  </action>
  <verify>npx tsc --noEmit src/generation/types.ts</verify>
  <done>Types file compiles without errors and exports FileType, AnalysisRequest, AnalysisResult, SummaryMetadata</done>
</task>

<task type="auto">
  <name>Task 2: Create file type detection patterns</name>
  <files>src/generation/detection/patterns.ts</files>
  <action>
Create src/generation/detection/patterns.ts with directory patterns and content-based detection:

```typescript
import type { FileType } from '../types.js';

// Directory name -> FileType mapping (case-insensitive)
export const DIRECTORY_PATTERNS: Record<string, FileType> = {
  // Component directories
  'components': 'component',
  'pages': 'component',
  'views': 'component',
  'screens': 'component',
  'layouts': 'component',

  // Service directories
  'services': 'service',
  'providers': 'service',

  // Utility directories
  'utils': 'util',
  'helpers': 'util',
  'lib': 'util',
  'common': 'util',

  // Type directories
  'types': 'type',
  'interfaces': 'type',
  '@types': 'type',
  'typings': 'type',

  // Test directories
  '__tests__': 'test',
  'tests': 'test',
  'spec': 'test',
  '__mocks__': 'test',

  // API directories
  'api': 'api',
  'routes': 'api',
  'handlers': 'api',
  'endpoints': 'api',
  'controllers': 'api',

  // Model directories
  'models': 'model',
  'entities': 'model',
  'domain': 'model',

  // Hook directories
  'hooks': 'hook',

  // Schema directories
  'schemas': 'schema',
  'validators': 'schema',
  'validation': 'schema',

  // Config directories
  'config': 'config',
  'configs': 'config',
};

// Content-based detection patterns (used when directory doesn't match)
export function detectFromContent(content: string): FileType {
  // Test files - check first as tests can contain other patterns
  if (/\b(describe|it|test|expect)\s*\(/.test(content) ||
      /\b(jest|vitest|mocha|chai)\b/.test(content)) {
    return 'test';
  }

  // React hook pattern: export (function|const) useXxx
  if (/export\s+(function|const)\s+use[A-Z]/.test(content)) {
    return 'hook';
  }

  // Zod/Yup schema pattern
  if (/\bz\.(object|string|number|boolean|array|enum|union)\b/.test(content) ||
      /\byup\.(object|string|number|boolean|array)\b/.test(content)) {
    return 'schema';
  }

  // React component pattern - JSX/TSX with capitalized export
  if (/export\s+(default\s+)?(function|const)\s+[A-Z][a-zA-Z]*/.test(content)) {
    if (/<[A-Z]|<\/|jsx|tsx|React|'react'|"react"/.test(content)) {
      return 'component';
    }
  }

  // Type-only file (only type/interface exports, no runtime code)
  if (/^(export\s+)?(interface|type)\s+/m.test(content)) {
    const hasRuntimeCode = /^(export\s+)?(function|const|let|var|class)\s+(?!type\s)/m.test(content);
    if (!hasRuntimeCode) {
      return 'type';
    }
  }

  // API route pattern (Next.js, Express-like)
  if (/export\s+(async\s+)?function\s+(GET|POST|PUT|DELETE|PATCH|HEAD|OPTIONS)\b/.test(content) ||
      /\.(get|post|put|delete|patch)\s*\(/.test(content) ||
      /router\.(get|post|put|delete)/.test(content)) {
    return 'api';
  }

  // Config file patterns
  if (/export\s+(default\s+)?{[\s\S]*?}/.test(content) &&
      /\b(config|options|settings|env)\b/i.test(content)) {
    return 'config';
  }

  // Service pattern (class with methods, or object with functions)
  if (/class\s+\w+Service\b/.test(content) ||
      /export\s+const\s+\w+Service\s*=/.test(content)) {
    return 'service';
  }

  // Model/Entity pattern
  if (/class\s+\w+(Entity|Model)\b/.test(content) ||
      /interface\s+\w+(Entity|Model)\b/.test(content) ||
      /prisma\.|@Entity|@Table|mongoose\./.test(content)) {
    return 'model';
  }

  return 'generic';
}
```

Create the detection directory first if it doesn't exist.
  </action>
  <verify>npx tsc --noEmit src/generation/detection/patterns.ts</verify>
  <done>Patterns module exports DIRECTORY_PATTERNS map and detectFromContent function</done>
</task>

<task type="auto">
  <name>Task 3: Create file type detector</name>
  <files>src/generation/detection/detector.ts</files>
  <action>
Create src/generation/detection/detector.ts that implements directory-first detection:

```typescript
import path from 'node:path';
import type { FileType } from '../types.js';
import { DIRECTORY_PATTERNS, detectFromContent } from './patterns.js';

// File name patterns that override directory detection
const TEST_FILE_PATTERNS = [
  /\.test\.[jt]sx?$/,
  /\.spec\.[jt]sx?$/,
  /_test\.[jt]sx?$/,
];

const CONFIG_FILE_PATTERNS = [
  /\.config\.[jt]s$/,
  /\.config\.m?[jt]s$/,
  /rc\.[jt]s$/,
  /rc\.m?[jt]s$/,
  /\.json$/,
  /\.ya?ml$/,
];

/**
 * Detect file type using directory-first strategy with content fallback.
 *
 * Detection order:
 * 1. File name patterns (tests, configs) - most specific
 * 2. Parent directory name - fast path for standard structures
 * 3. Content analysis - fallback for edge cases
 */
export function detectFileType(filePath: string, content: string): FileType {
  const fileName = path.basename(filePath);

  // 1. File name patterns take precedence
  if (TEST_FILE_PATTERNS.some(pattern => pattern.test(fileName))) {
    return 'test';
  }

  if (CONFIG_FILE_PATTERNS.some(pattern => pattern.test(fileName))) {
    return 'config';
  }

  // 2. Directory-based detection
  const dirPath = path.dirname(filePath);
  const pathParts = dirPath.split(path.sep);

  // Check each directory level (inner to outer)
  for (let i = pathParts.length - 1; i >= 0; i--) {
    const dirName = pathParts[i].toLowerCase();
    if (dirName && DIRECTORY_PATTERNS[dirName]) {
      return DIRECTORY_PATTERNS[dirName];
    }
  }

  // 3. Content-based fallback
  return detectFromContent(content);
}
```

This follows the directory-first detection pattern from RESEARCH.md.
  </action>
  <verify>npx tsc --noEmit src/generation/detection/detector.ts</verify>
  <done>Detector module exports detectFileType function with three-tier detection strategy</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` - Full project compiles without errors
2. Verify exports are accessible:
```typescript
import { FileType, AnalysisRequest } from './src/generation/types.js';
import { detectFileType } from './src/generation/detection/detector.js';
import { DIRECTORY_PATTERNS, detectFromContent } from './src/generation/detection/patterns.js';
```
</verification>

<success_criteria>
- [ ] src/generation/types.ts exports FileType, AnalysisRequest, AnalysisResult, SummaryMetadata
- [ ] src/generation/detection/patterns.ts exports DIRECTORY_PATTERNS and detectFromContent
- [ ] src/generation/detection/detector.ts exports detectFileType
- [ ] All files compile without TypeScript errors
- [ ] File type detection prioritizes: file name patterns > directory > content
</success_criteria>

<output>
After completion, create `.planning/phases/02-documentation-generation/02-01-SUMMARY.md`
</output>
