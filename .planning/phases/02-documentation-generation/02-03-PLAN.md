---
phase: 02-documentation-generation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/generation/prompts/types.ts
  - src/generation/prompts/templates.ts
  - src/generation/prompts/builder.ts
  - src/generation/prompts/index.ts
autonomous: true

must_haves:
  truths:
    - "Each file type has a dedicated prompt template with type-specific instructions"
    - "Prompt builder combines template + file content + context into complete prompt"
    - "Templates follow CONTEXT.md guidelines (300-500 words, balanced detail)"
  artifacts:
    - path: "src/generation/prompts/types.ts"
      provides: "Prompt-related type definitions"
      exports: ["PromptTemplate", "PromptContext", "SummaryGuidelines"]
    - path: "src/generation/prompts/templates.ts"
      provides: "File-type-specific prompt templates"
      exports: ["TEMPLATES", "getTemplate"]
    - path: "src/generation/prompts/builder.ts"
      provides: "Prompt construction logic"
      exports: ["buildPrompt", "buildChunkPrompt", "buildSynthesisPrompt"]
    - path: "src/generation/prompts/index.ts"
      provides: "Re-exports for prompts module"
  key_links:
    - from: "src/generation/prompts/builder.ts"
      to: "src/generation/prompts/templates.ts"
      via: "imports getTemplate for template lookup"
      pattern: "import.*templates"
---

<objective>
Create file-type-specific prompt templates for generating high-quality summaries.

Purpose: Different file types need different analysis approaches. A React component needs JSX/props analysis, while a Zod schema needs validation rule extraction. Type-specific templates produce better quality summaries than generic prompts.

Output: Template system with 11 file-type templates and a builder that constructs complete prompts for the host LLM.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-documentation-generation/02-CONTEXT.md
@.planning/phases/02-documentation-generation/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create prompt types</name>
  <files>src/generation/prompts/types.ts</files>
  <action>
Create src/generation/prompts/types.ts with type definitions:

```typescript
import type { FileType } from '../types.js';

/**
 * Template for generating file summaries.
 * Each file type has a dedicated template with specific instructions.
 */
export interface PromptTemplate {
  /** File type this template applies to */
  fileType: FileType;
  /** System instructions for the LLM */
  systemPrompt: string;
  /** User prompt template with placeholders */
  userPrompt: string;
  /** Sections to emphasize in analysis */
  focusAreas: string[];
}

/**
 * Context provided when building a prompt.
 */
export interface PromptContext {
  /** Absolute path to the file */
  filePath: string;
  /** File content to analyze */
  content: string;
  /** Detected file type */
  fileType: FileType;
  /** Related files for additional context */
  contextFiles?: Array<{
    path: string;
    content: string;
  }>;
}

/**
 * Guidelines for summary generation (from CONTEXT.md).
 */
export const SUMMARY_GUIDELINES = {
  /** Target word count range */
  targetLength: { min: 300, max: 500 },
  /** What to include */
  include: [
    'Purpose and responsibility',
    'Public interface (exports, key functions)',
    'Key patterns and notable algorithms',
    'Dependencies with usage context',
    'Key function signatures as code snippets',
    'Tightly coupled sibling files',
  ],
  /** What to exclude */
  exclude: [
    'Internal implementation details',
    'Generic TODOs/FIXMEs (keep only security/breaking)',
    'Broad architectural relationships (handled by AGENTS.md)',
  ],
} as const;

/**
 * Context for chunk summarization (large files).
 */
export interface ChunkContext extends PromptContext {
  /** Chunk index (0-based) */
  chunkIndex: number;
  /** Total number of chunks */
  totalChunks: number;
  /** Line range in original file */
  lineRange: { start: number; end: number };
}

/**
 * Context for synthesizing chunk summaries.
 */
export interface SynthesisContext {
  /** Original file path */
  filePath: string;
  /** Detected file type */
  fileType: FileType;
  /** Summaries from each chunk */
  chunkSummaries: string[];
}
```

Create the prompts directory: `mkdir -p src/generation/prompts`
  </action>
  <verify>npx tsc --noEmit src/generation/prompts/types.ts</verify>
  <done>Types file exports PromptTemplate, PromptContext, SUMMARY_GUIDELINES, ChunkContext, SynthesisContext</done>
</task>

<task type="auto">
  <name>Task 2: Create file-type templates</name>
  <files>src/generation/prompts/templates.ts</files>
  <action>
Create src/generation/prompts/templates.ts with templates for each file type:

```typescript
import type { FileType } from '../types.js';
import type { PromptTemplate } from './types.js';

const BASE_SYSTEM_PROMPT = `You are analyzing source code to generate documentation for AI coding assistants.

Guidelines:
- Be concise but comprehensive (300-500 words)
- Focus on what the code DOES and HOW to use it
- Include key function signatures as code snippets
- Note dependencies and their purposes
- Mention only critical TODOs (security, breaking issues)
- Reference tightly coupled files (used together)`;

const COMPONENT_TEMPLATE: PromptTemplate = {
  fileType: 'component',
  systemPrompt: BASE_SYSTEM_PROMPT,
  userPrompt: `Analyze this {{FRAMEWORK}} component and generate a summary.

File: {{FILE_PATH}}

\`\`\`{{LANG}}
{{CONTENT}}
\`\`\`

Include in your summary:
1. **Purpose**: What this component renders and when it's used
2. **Props**: List props with types and descriptions
3. **State**: Key state variables and their roles
4. **Hooks**: Custom hooks used and why
5. **Events**: Key event handlers and their behavior
6. **Dependencies**: Imported modules and their usage
7. **Related Files**: Tightly coupled components/utilities`,
  focusAreas: ['props', 'state', 'rendering logic', 'event handlers'],
};

const SERVICE_TEMPLATE: PromptTemplate = {
  fileType: 'service',
  systemPrompt: BASE_SYSTEM_PROMPT,
  userPrompt: `Analyze this service module and generate a summary.

File: {{FILE_PATH}}

\`\`\`{{LANG}}
{{CONTENT}}
\`\`\`

Include in your summary:
1. **Purpose**: What business logic this service handles
2. **Public Interface**: Exported functions/methods with signatures
3. **Dependencies**: External services, APIs, databases used
4. **Error Handling**: How errors are managed
5. **Side Effects**: External mutations, API calls, file operations
6. **Patterns**: Notable patterns (singleton, factory, etc.)`,
  focusAreas: ['public methods', 'dependencies', 'error handling', 'side effects'],
};

const UTIL_TEMPLATE: PromptTemplate = {
  fileType: 'util',
  systemPrompt: BASE_SYSTEM_PROMPT,
  userPrompt: `Analyze this utility module and generate a summary.

File: {{FILE_PATH}}

\`\`\`{{LANG}}
{{CONTENT}}
\`\`\`

Include in your summary:
1. **Purpose**: What problems these utilities solve
2. **Functions**: List each exported function with signature and brief description
3. **Pure vs Impure**: Note which functions have side effects
4. **Common Usage**: Typical use cases
5. **Edge Cases**: Notable edge case handling`,
  focusAreas: ['function signatures', 'input/output types', 'edge cases'],
};

const TYPE_TEMPLATE: PromptTemplate = {
  fileType: 'type',
  systemPrompt: BASE_SYSTEM_PROMPT,
  userPrompt: `Analyze this type definitions file and generate a summary.

File: {{FILE_PATH}}

\`\`\`{{LANG}}
{{CONTENT}}
\`\`\`

Include in your summary:
1. **Purpose**: What domain these types represent
2. **Main Types**: List key interfaces/types with descriptions
3. **Relationships**: How types relate to each other
4. **Usage**: Where these types are typically used
5. **Constraints**: Notable validation or narrowing`,
  focusAreas: ['interface definitions', 'type relationships', 'generics'],
};

const TEST_TEMPLATE: PromptTemplate = {
  fileType: 'test',
  systemPrompt: BASE_SYSTEM_PROMPT,
  userPrompt: `Analyze this test file and generate a summary.

File: {{FILE_PATH}}

\`\`\`{{LANG}}
{{CONTENT}}
\`\`\`

Include in your summary:
1. **Subject**: What module/function is being tested
2. **Test Cases**: Group and describe test scenarios
3. **Coverage**: What behaviors are tested
4. **Fixtures**: Test data and mocks used
5. **Patterns**: Testing patterns (AAA, mocking strategy)`,
  focusAreas: ['test descriptions', 'assertions', 'mocks'],
};

const CONFIG_TEMPLATE: PromptTemplate = {
  fileType: 'config',
  systemPrompt: BASE_SYSTEM_PROMPT,
  userPrompt: `Analyze this configuration file and generate a summary.

File: {{FILE_PATH}}

\`\`\`{{LANG}}
{{CONTENT}}
\`\`\`

Include in your summary:
1. **Purpose**: What this configures
2. **Key Settings**: Important configuration values
3. **Defaults**: Notable default values
4. **Environment**: Environment-specific settings
5. **Dependencies**: What tools/libraries this configures`,
  focusAreas: ['settings', 'defaults', 'environment variables'],
};

const API_TEMPLATE: PromptTemplate = {
  fileType: 'api',
  systemPrompt: BASE_SYSTEM_PROMPT,
  userPrompt: `Analyze this API route/handler and generate a summary.

File: {{FILE_PATH}}

\`\`\`{{LANG}}
{{CONTENT}}
\`\`\`

Include in your summary:
1. **Endpoint**: HTTP method and path
2. **Request**: Expected request body/params/query
3. **Response**: Response format and status codes
4. **Auth**: Authentication/authorization requirements
5. **Validation**: Input validation rules
6. **Errors**: Error responses and codes`,
  focusAreas: ['HTTP methods', 'request/response shapes', 'validation', 'auth'],
};

const MODEL_TEMPLATE: PromptTemplate = {
  fileType: 'model',
  systemPrompt: BASE_SYSTEM_PROMPT,
  userPrompt: `Analyze this data model/entity and generate a summary.

File: {{FILE_PATH}}

\`\`\`{{LANG}}
{{CONTENT}}
\`\`\`

Include in your summary:
1. **Entity**: What this model represents
2. **Fields**: List fields with types and constraints
3. **Relations**: Relationships to other models
4. **Indexes**: Database indexes defined
5. **Methods**: Model methods and their purposes`,
  focusAreas: ['fields', 'relations', 'constraints', 'indexes'],
};

const HOOK_TEMPLATE: PromptTemplate = {
  fileType: 'hook',
  systemPrompt: BASE_SYSTEM_PROMPT,
  userPrompt: `Analyze this React hook and generate a summary.

File: {{FILE_PATH}}

\`\`\`{{LANG}}
{{CONTENT}}
\`\`\`

Include in your summary:
1. **Purpose**: What state/behavior this hook provides
2. **Parameters**: Input parameters with types
3. **Return Value**: What the hook returns
4. **State**: Internal state managed
5. **Effects**: Side effects and cleanup
6. **Dependencies**: Hooks and utilities used`,
  focusAreas: ['parameters', 'return value', 'effects', 'cleanup'],
};

const SCHEMA_TEMPLATE: PromptTemplate = {
  fileType: 'schema',
  systemPrompt: BASE_SYSTEM_PROMPT,
  userPrompt: `Analyze this validation schema and generate a summary.

File: {{FILE_PATH}}

\`\`\`{{LANG}}
{{CONTENT}}
\`\`\`

Include in your summary:
1. **Purpose**: What data this schema validates
2. **Shape**: Top-level structure of the schema
3. **Fields**: Key fields with validation rules
4. **Transforms**: Data transformations applied
5. **Defaults**: Default values
6. **Errors**: Custom error messages`,
  focusAreas: ['validation rules', 'transforms', 'defaults', 'errors'],
};

const GENERIC_TEMPLATE: PromptTemplate = {
  fileType: 'generic',
  systemPrompt: BASE_SYSTEM_PROMPT,
  userPrompt: `Analyze this source file and generate a summary.

File: {{FILE_PATH}}

\`\`\`{{LANG}}
{{CONTENT}}
\`\`\`

Include in your summary:
1. **Purpose**: What this file does
2. **Exports**: Public interface (functions, classes, constants)
3. **Dependencies**: Imported modules and their usage
4. **Patterns**: Notable implementation patterns
5. **Related**: Tightly coupled files`,
  focusAreas: ['exports', 'dependencies', 'patterns'],
};

/**
 * Map of file types to their prompt templates.
 */
export const TEMPLATES: Record<FileType, PromptTemplate> = {
  component: COMPONENT_TEMPLATE,
  service: SERVICE_TEMPLATE,
  util: UTIL_TEMPLATE,
  type: TYPE_TEMPLATE,
  test: TEST_TEMPLATE,
  config: CONFIG_TEMPLATE,
  api: API_TEMPLATE,
  model: MODEL_TEMPLATE,
  hook: HOOK_TEMPLATE,
  schema: SCHEMA_TEMPLATE,
  generic: GENERIC_TEMPLATE,
};

/**
 * Get the prompt template for a file type.
 */
export function getTemplate(fileType: FileType): PromptTemplate {
  return TEMPLATES[fileType];
}
```
  </action>
  <verify>npx tsc --noEmit src/generation/prompts/templates.ts</verify>
  <done>Templates module exports TEMPLATES map and getTemplate function for all 11 file types</done>
</task>

<task type="auto">
  <name>Task 3: Create prompt builder</name>
  <files>src/generation/prompts/builder.ts, src/generation/prompts/index.ts</files>
  <action>
Create src/generation/prompts/builder.ts:

```typescript
import path from 'node:path';
import type { PromptContext, ChunkContext, SynthesisContext } from './types.js';
import { getTemplate } from './templates.js';

/**
 * Detect language from file extension for syntax highlighting.
 */
function detectLanguage(filePath: string): string {
  const ext = path.extname(filePath).toLowerCase();
  const langMap: Record<string, string> = {
    '.ts': 'typescript',
    '.tsx': 'tsx',
    '.js': 'javascript',
    '.jsx': 'jsx',
    '.py': 'python',
    '.rb': 'ruby',
    '.go': 'go',
    '.rs': 'rust',
    '.java': 'java',
    '.kt': 'kotlin',
    '.swift': 'swift',
    '.cs': 'csharp',
    '.php': 'php',
    '.vue': 'vue',
    '.svelte': 'svelte',
    '.json': 'json',
    '.yaml': 'yaml',
    '.yml': 'yaml',
    '.md': 'markdown',
    '.css': 'css',
    '.scss': 'scss',
    '.html': 'html',
  };
  return langMap[ext] ?? 'text';
}

/**
 * Detect framework from file content for component templates.
 */
function detectFramework(content: string): string {
  if (content.includes('from \'react\'') || content.includes('from "react"')) {
    return 'React';
  }
  if (content.includes('from \'vue\'') || content.includes('from "vue"')) {
    return 'Vue';
  }
  if (content.includes('from \'svelte\'') || content.includes('.svelte')) {
    return 'Svelte';
  }
  if (content.includes('@angular')) {
    return 'Angular';
  }
  return 'JavaScript';
}

/**
 * Build a complete prompt for file analysis.
 */
export function buildPrompt(context: PromptContext): {
  system: string;
  user: string;
} {
  const template = getTemplate(context.fileType);
  const lang = detectLanguage(context.filePath);
  const framework = detectFramework(context.content);

  let userPrompt = template.userPrompt
    .replace(/\{\{FILE_PATH\}\}/g, context.filePath)
    .replace(/\{\{CONTENT\}\}/g, context.content)
    .replace(/\{\{LANG\}\}/g, lang)
    .replace(/\{\{FRAMEWORK\}\}/g, framework);

  // Add context files if provided
  if (context.contextFiles && context.contextFiles.length > 0) {
    const contextSection = context.contextFiles
      .map(f => `\n### ${f.path}\n\`\`\`${detectLanguage(f.path)}\n${f.content}\n\`\`\``)
      .join('\n');
    userPrompt += `\n\n## Related Files\n${contextSection}`;
  }

  return {
    system: template.systemPrompt,
    user: userPrompt,
  };
}

/**
 * Build a prompt for summarizing a chunk of a large file.
 */
export function buildChunkPrompt(context: ChunkContext): {
  system: string;
  user: string;
} {
  const template = getTemplate(context.fileType);
  const lang = detectLanguage(context.filePath);

  const system = `${template.systemPrompt}

This is chunk ${context.chunkIndex + 1} of ${context.totalChunks} from a large file.
Focus on what THIS chunk contains. The chunks will be synthesized later.`;

  const user = `Analyze this code chunk and generate a partial summary.

File: ${context.filePath} (lines ${context.lineRange.start}-${context.lineRange.end})
Chunk: ${context.chunkIndex + 1} of ${context.totalChunks}

\`\`\`${lang}
${context.content}
\`\`\`

Summarize what this chunk contains:
- Functions/classes defined
- Key logic and patterns
- Dependencies used
- Notable details

Keep it concise - this will be combined with other chunks.`;

  return { system, user };
}

/**
 * Build a prompt for synthesizing chunk summaries into final summary.
 */
export function buildSynthesisPrompt(context: SynthesisContext): {
  system: string;
  user: string;
} {
  const template = getTemplate(context.fileType);

  const system = `${template.systemPrompt}

You are synthesizing chunk summaries into a final, cohesive summary.`;

  const chunkSection = context.chunkSummaries
    .map((summary, i) => `### Chunk ${i + 1}\n${summary}`)
    .join('\n\n');

  const user = `Synthesize these chunk summaries into a final summary for the file.

File: ${context.filePath}
File Type: ${context.fileType}

## Chunk Summaries

${chunkSection}

## Instructions

Create a unified summary (300-500 words) that:
1. Combines insights from all chunks
2. Eliminates redundancy
3. Presents a coherent overview of the entire file
4. Follows the format for ${context.fileType} files

Focus on:
${template.focusAreas.map(area => `- ${area}`).join('\n')}`;

  return { system, user };
}
```

Then create src/generation/prompts/index.ts:

```typescript
export type { PromptTemplate, PromptContext, ChunkContext, SynthesisContext } from './types.js';
export { SUMMARY_GUIDELINES } from './types.js';
export { TEMPLATES, getTemplate } from './templates.js';
export { buildPrompt, buildChunkPrompt, buildSynthesisPrompt } from './builder.js';
```
  </action>
  <verify>npx tsc --noEmit src/generation/prompts/index.ts</verify>
  <done>Builder module exports buildPrompt, buildChunkPrompt, buildSynthesisPrompt. Index re-exports all prompt functionality.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` - Full project compiles without errors
2. Verify all templates are accessible:
```typescript
import { getTemplate, buildPrompt, TEMPLATES } from './src/generation/prompts/index.js';
const template = getTemplate('component');
console.log(template.focusAreas); // ['props', 'state', 'rendering logic', 'event handlers']
```
</verification>

<success_criteria>
- [ ] src/generation/prompts/types.ts exports PromptTemplate, PromptContext, SUMMARY_GUIDELINES
- [ ] src/generation/prompts/templates.ts exports TEMPLATES map with all 11 file types
- [ ] src/generation/prompts/builder.ts exports buildPrompt, buildChunkPrompt, buildSynthesisPrompt
- [ ] All templates include type-specific focus areas and instructions
- [ ] Prompt builder handles language detection and framework detection
</success_criteria>

<output>
After completion, create `.planning/phases/02-documentation-generation/02-03-SUMMARY.md`
</output>
