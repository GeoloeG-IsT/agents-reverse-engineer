---
phase: 02-documentation-generation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/generation/budget/counter.ts
  - src/generation/budget/tracker.ts
  - src/generation/budget/chunker.ts
  - src/generation/budget/index.ts
autonomous: true

must_haves:
  truths:
    - "Token counting returns accurate BPE token count for code files"
    - "Budget tracker prevents processing when budget exhausted"
    - "Large files are chunked with overlap for context continuity"
    - "Budget exhaustion produces report of completed and remaining files"
  artifacts:
    - path: "src/generation/budget/counter.ts"
      provides: "Token counting with gpt-tokenizer"
      exports: ["countTokens", "isWithinLimit"]
    - path: "src/generation/budget/tracker.ts"
      provides: "Project-wide budget tracking"
      exports: ["BudgetTracker", "BudgetReport"]
    - path: "src/generation/budget/chunker.ts"
      provides: "Large file chunking for map-reduce"
      exports: ["chunkFile", "Chunk"]
    - path: "src/generation/budget/index.ts"
      provides: "Re-exports for budget module"
  key_links:
    - from: "src/generation/budget/tracker.ts"
      to: "src/generation/budget/counter.ts"
      via: "uses countTokens for estimation"
      pattern: "import.*counter"
    - from: "src/generation/budget/chunker.ts"
      to: "src/generation/budget/counter.ts"
      via: "uses countTokens for chunk sizing"
      pattern: "import.*counter"
---

<objective>
Create token budget management system for preventing cost explosion on large repositories.

Purpose: Token budgets ensure the tool doesn't consume excessive resources on large codebases. Budget tracking enables breadth-first coverage (summarize everything shallowly before going deep) and graceful degradation when budget is exhausted.

Output: Token counter using gpt-tokenizer, budget tracker for project-wide limits, and chunker for large files that exceed single-pass limits.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-documentation-generation/02-CONTEXT.md
@.planning/phases/02-documentation-generation/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install gpt-tokenizer and create token counter</name>
  <files>src/generation/budget/counter.ts</files>
  <action>
First, install gpt-tokenizer:
```bash
npm install gpt-tokenizer
```

Then create src/generation/budget/counter.ts:

```typescript
import { encode, isWithinTokenLimit as checkLimit } from 'gpt-tokenizer';

/**
 * Count tokens in content using BPE tokenization.
 * Uses cl100k_base encoding (compatible with Claude/GPT-4).
 *
 * @param content - Text to count tokens in
 * @returns Token count
 */
export function countTokens(content: string): number {
  return encode(content).length;
}

/**
 * Check if content fits within token limit without fully encoding.
 * More efficient than counting when you only need a boolean check.
 *
 * @param content - Text to check
 * @param limit - Maximum allowed tokens
 * @returns true if content is within limit
 */
export function isWithinLimit(content: string, limit: number): boolean {
  return checkLimit(content, limit);
}

/**
 * Estimate prompt overhead for a given file type.
 * Includes template tokens + system prompt portion.
 *
 * @param fileType - Type of file being summarized
 * @returns Estimated overhead in tokens
 */
export function estimatePromptOverhead(fileType: string): number {
  // Base overhead for all prompts (system instructions, formatting)
  const BASE_OVERHEAD = 500;

  // Additional overhead by file type (templates vary in size)
  const TYPE_OVERHEAD: Record<string, number> = {
    component: 200,
    service: 150,
    api: 180,
    model: 120,
    schema: 100,
    generic: 100,
  };

  return BASE_OVERHEAD + (TYPE_OVERHEAD[fileType] ?? 100);
}
```

Create the budget directory: `mkdir -p src/generation/budget`
  </action>
  <verify>npx tsc --noEmit src/generation/budget/counter.ts && node -e "import('./dist/generation/budget/counter.js').then(m => console.log(m.countTokens('hello world')))"</verify>
  <done>Counter module exports countTokens, isWithinLimit, estimatePromptOverhead functions</done>
</task>

<task type="auto">
  <name>Task 2: Create budget tracker</name>
  <files>src/generation/budget/tracker.ts</files>
  <action>
Create src/generation/budget/tracker.ts for project-wide budget management:

```typescript
import { countTokens } from './counter.js';

export interface BudgetReport {
  totalBudget: number;
  used: number;
  remaining: number;
  percentUsed: number;
  filesProcessed: number;
  filesRemaining: number;
  averagePerFile: number;
  exhausted: boolean;
  completedFiles: string[];
  skippedFiles: string[];
}

export interface FileEstimate {
  filePath: string;
  tokens: number;
  canProcess: boolean;
}

/**
 * Tracks token budget across the entire project.
 * Enforces budget limits and reports progress.
 */
export class BudgetTracker {
  private totalBudget: number;
  private used: number = 0;
  private filesProcessed: number = 0;
  private totalFiles: number;
  private completedFiles: string[] = [];
  private skippedFiles: string[] = [];

  constructor(totalBudget: number, totalFiles: number) {
    this.totalBudget = totalBudget;
    this.totalFiles = totalFiles;
  }

  /**
   * Check if there's enough budget to process a file.
   */
  canProcess(estimatedTokens: number): boolean {
    return this.remaining >= estimatedTokens;
  }

  /**
   * Get remaining budget.
   */
  get remaining(): number {
    return this.totalBudget - this.used;
  }

  /**
   * Estimate tokens for a file and check if it can be processed.
   */
  estimate(filePath: string, content: string, promptOverhead: number): FileEstimate {
    const contentTokens = countTokens(content);
    const totalTokens = contentTokens + promptOverhead;

    return {
      filePath,
      tokens: totalTokens,
      canProcess: this.canProcess(totalTokens),
    };
  }

  /**
   * Record that a file was processed, consuming budget.
   */
  recordProcessed(filePath: string, tokensUsed: number): void {
    this.used += tokensUsed;
    this.filesProcessed++;
    this.completedFiles.push(filePath);
  }

  /**
   * Record that a file was skipped due to budget constraints.
   */
  recordSkipped(filePath: string): void {
    this.skippedFiles.push(filePath);
  }

  /**
   * Check if budget is exhausted (should stop processing).
   */
  isExhausted(): boolean {
    return this.remaining <= 0;
  }

  /**
   * Get a report of budget status.
   */
  getReport(): BudgetReport {
    return {
      totalBudget: this.totalBudget,
      used: this.used,
      remaining: this.remaining,
      percentUsed: this.totalBudget > 0 ? (this.used / this.totalBudget) * 100 : 0,
      filesProcessed: this.filesProcessed,
      filesRemaining: this.totalFiles - this.filesProcessed,
      averagePerFile: this.filesProcessed > 0 ? this.used / this.filesProcessed : 0,
      exhausted: this.isExhausted(),
      completedFiles: [...this.completedFiles],
      skippedFiles: [...this.skippedFiles],
    };
  }

  /**
   * Create a summary message for CLI output.
   */
  getSummaryMessage(): string {
    const report = this.getReport();
    const lines = [
      `Token budget: ${report.used.toLocaleString()} / ${report.totalBudget.toLocaleString()} (${report.percentUsed.toFixed(1)}%)`,
      `Files processed: ${report.filesProcessed} / ${this.totalFiles}`,
    ];

    if (report.skippedFiles.length > 0) {
      lines.push(`Files skipped (budget): ${report.skippedFiles.length}`);
    }

    if (report.exhausted) {
      lines.push('Budget exhausted - some files were not processed');
    }

    return lines.join('\n');
  }
}
```
  </action>
  <verify>npx tsc --noEmit src/generation/budget/tracker.ts</verify>
  <done>BudgetTracker class tracks budget, records processed/skipped files, and generates reports</done>
</task>

<task type="auto">
  <name>Task 3: Create file chunker for large files</name>
  <files>src/generation/budget/chunker.ts, src/generation/budget/index.ts</files>
  <action>
Create src/generation/budget/chunker.ts for map-reduce summarization of large files:

```typescript
import { countTokens } from './counter.js';

export interface Chunk {
  index: number;
  content: string;
  tokens: number;
  startLine: number;
  endLine: number;
}

export interface ChunkOptions {
  /** Target tokens per chunk (default: 3000) */
  chunkSize?: number;
  /** Lines of overlap between chunks (default: 10) */
  overlapLines?: number;
}

const DEFAULT_CHUNK_SIZE = 3000;
const DEFAULT_OVERLAP_LINES = 10;

/**
 * Check if a file needs to be chunked for processing.
 *
 * @param content - File content
 * @param threshold - Token threshold for chunking (default: 4000)
 * @returns true if file should be chunked
 */
export function needsChunking(content: string, threshold: number = 4000): boolean {
  return countTokens(content) > threshold;
}

/**
 * Split a large file into overlapping chunks for map-reduce summarization.
 *
 * Each chunk includes some overlap with the previous chunk to maintain
 * context continuity. The overlap uses line-based boundaries to avoid
 * cutting in the middle of statements.
 *
 * @param content - File content to chunk
 * @param options - Chunking options
 * @returns Array of chunks with metadata
 */
export function chunkFile(content: string, options: ChunkOptions = {}): Chunk[] {
  const {
    chunkSize = DEFAULT_CHUNK_SIZE,
    overlapLines = DEFAULT_OVERLAP_LINES,
  } = options;

  const lines = content.split('\n');
  const chunks: Chunk[] = [];

  let currentLines: string[] = [];
  let currentTokens = 0;
  let startLine = 0;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const lineTokens = countTokens(line + '\n');

    // Check if adding this line would exceed chunk size
    if (currentTokens + lineTokens > chunkSize && currentLines.length > 0) {
      // Save current chunk
      chunks.push({
        index: chunks.length,
        content: currentLines.join('\n'),
        tokens: currentTokens,
        startLine,
        endLine: i - 1,
      });

      // Start new chunk with overlap from previous
      const overlapStart = Math.max(0, currentLines.length - overlapLines);
      const overlapContent = currentLines.slice(overlapStart);
      currentLines = overlapContent;
      currentTokens = countTokens(overlapContent.join('\n'));
      startLine = i - overlapContent.length;
    }

    currentLines.push(line);
    currentTokens += lineTokens;
  }

  // Add final chunk if there's remaining content
  if (currentLines.length > 0) {
    chunks.push({
      index: chunks.length,
      content: currentLines.join('\n'),
      tokens: currentTokens,
      startLine,
      endLine: lines.length - 1,
    });
  }

  return chunks;
}

/**
 * Get total tokens across all chunks.
 */
export function getTotalChunkTokens(chunks: Chunk[]): number {
  return chunks.reduce((sum, chunk) => sum + chunk.tokens, 0);
}
```

Then create src/generation/budget/index.ts to re-export:

```typescript
export { countTokens, isWithinLimit, estimatePromptOverhead } from './counter.js';
export { BudgetTracker, type BudgetReport, type FileEstimate } from './tracker.js';
export { chunkFile, needsChunking, getTotalChunkTokens, type Chunk, type ChunkOptions } from './chunker.js';
```
  </action>
  <verify>npx tsc --noEmit src/generation/budget/index.ts</verify>
  <done>Chunker module exports chunkFile, needsChunking, Chunk type. Index re-exports all budget functionality.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm install` - gpt-tokenizer installed
2. `npx tsc --noEmit` - Full project compiles without errors
3. Token counting works:
```bash
npx tsx -e "import { countTokens } from './src/generation/budget/counter.js'; console.log(countTokens('function hello() { return \"world\"; }'));"
```
4. Chunking works on large content
</verification>

<success_criteria>
- [ ] gpt-tokenizer is installed in package.json
- [ ] src/generation/budget/counter.ts exports countTokens, isWithinLimit
- [ ] src/generation/budget/tracker.ts exports BudgetTracker class with canProcess, record, getReport
- [ ] src/generation/budget/chunker.ts exports chunkFile, needsChunking, Chunk
- [ ] src/generation/budget/index.ts re-exports all budget functionality
- [ ] Token counting returns accurate counts (not word-based estimation)
</success_criteria>

<output>
After completion, create `.planning/phases/02-documentation-generation/02-02-SUMMARY.md`
</output>
