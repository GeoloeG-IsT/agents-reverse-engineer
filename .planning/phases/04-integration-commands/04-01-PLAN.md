---
phase: 04-integration-commands
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/integration/types.ts
  - src/integration/detect.ts
  - src/integration/templates.ts
autonomous: true

must_haves:
  truths:
    - "Environment detection identifies Claude Code by .claude/ directory presence"
    - "Environment detection identifies OpenCode by .opencode/ directory presence"
    - "Templates produce valid markdown command files"
  artifacts:
    - path: "src/integration/types.ts"
      provides: "Environment and template type definitions"
      exports: ["DetectedEnvironment", "IntegrationTemplate", "EnvironmentType"]
    - path: "src/integration/detect.ts"
      provides: "Environment detection function"
      exports: ["detectEnvironments"]
    - path: "src/integration/templates.ts"
      provides: "Template content generators"
      exports: ["getClaudeTemplates", "getOpenCodeTemplates", "getHookTemplate"]
  key_links:
    - from: "src/integration/detect.ts"
      to: "node:fs"
      via: "existsSync checks"
      pattern: "existsSync.*\\.claude|existsSync.*\\.opencode"
    - from: "src/integration/templates.ts"
      to: "src/integration/types.ts"
      via: "type imports"
      pattern: "import.*IntegrationTemplate"
---

<objective>
Create the integration infrastructure for detecting AI assistant environments and generating command file templates.

Purpose: Enables `/ar:init --integration` to generate appropriate command files for any detected AI coding assistant (Claude Code, OpenCode, etc.)

Output:
- `src/integration/types.ts` - Type definitions for environments and templates
- `src/integration/detect.ts` - Environment detection logic
- `src/integration/templates.ts` - Template content generators for each environment
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-integration-commands/04-RESEARCH.md
@.planning/phases/04-integration-commands/04-CONTEXT.md
@src/cli/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create integration type definitions</name>
  <files>src/integration/types.ts</files>
  <action>
Create `src/integration/types.ts` with:

1. `EnvironmentType` - union type: 'claude' | 'opencode' | 'aider'

2. `DetectedEnvironment` interface:
   - `type: EnvironmentType`
   - `configDir: string` (e.g., '.claude', '.opencode')
   - `detected: boolean`

3. `IntegrationTemplate` interface:
   - `filename: string` (e.g., 'generate.md')
   - `path: string` (relative path like '.claude/commands/ar/generate.md')
   - `content: string` (the template content)

4. `IntegrationResult` interface:
   - `environment: EnvironmentType`
   - `filesCreated: string[]`
   - `filesSkipped: string[]` (already exist)

Follow project patterns:
- ESM exports
- JSDoc comments
- No default exports
  </action>
  <verify>
`npx tsc --noEmit` passes with no errors on the new file
  </verify>
  <done>
Type definitions exist and compile without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create environment detection module</name>
  <files>src/integration/detect.ts</files>
  <action>
Create `src/integration/detect.ts` with:

1. `detectEnvironments(projectRoot: string): DetectedEnvironment[]` function:
   - Check for `.claude/` directory OR `CLAUDE.md` file -> Claude Code detected
   - Check for `.opencode/` directory -> OpenCode detected
   - Check for `.aider.conf.yml` OR `.aider/` directory -> Aider detected
   - Return array of all detected environments (can be multiple)
   - Use `node:fs` existsSync for checks (synchronous is fine, runs once)

2. `hasEnvironment(projectRoot: string, type: EnvironmentType): boolean` helper
   - Quick check for specific environment

Import types from `./types.js` (ESM .js extension).
Use `node:path` for path.join operations.
  </action>
  <verify>
`npx tsc --noEmit` passes. Create a quick test:
```bash
node -e "import('./dist/integration/detect.js').then(m => console.log(m.detectEnvironments('.')))"
```
After build, should detect at least 'claude' (since this project has .claude/).
  </verify>
  <done>
detectEnvironments('.') returns array including {type: 'claude', configDir: '.claude', detected: true}
  </done>
</task>

<task type="auto">
  <name>Task 3: Create template generators</name>
  <files>src/integration/templates.ts</files>
  <action>
Create `src/integration/templates.ts` with template generators:

1. `getClaudeTemplates(): IntegrationTemplate[]` - Returns array of templates:

   a. generate.md template:
   ```markdown
   ---
   name: ar:generate
   description: Generate AI-friendly documentation for the entire codebase
   argument-hint: "[--budget N] [--dry-run] [--verbose]"
   ---

   Generate comprehensive documentation for this codebase using agents-reverse.

   <execution>
   Run the agents-reverse generate command:

   \`\`\`bash
   ar generate $ARGUMENTS
   \`\`\`

   After completion, summarize:
   - Number of files analyzed
   - Token budget used
   - Any files skipped due to budget
   - Location of generated CLAUDE.md and AGENTS.md files

   If budget concerns arise, suggest \`--budget N\` to adjust.
   </execution>
   ```

   b. update.md template:
   ```markdown
   ---
   name: ar:update
   description: Incrementally update documentation for changed files
   argument-hint: "[--uncommitted] [--dry-run] [--verbose]"
   ---

   Update documentation for files that changed since last run.

   <execution>
   Run the agents-reverse update command:

   \`\`\`bash
   ar update $ARGUMENTS
   \`\`\`

   After completion, summarize:
   - Files updated
   - Files unchanged
   - Any orphaned docs cleaned up

   Use \`--uncommitted\` to include staged but uncommitted changes.
   </execution>
   ```

   c. init.md template:
   ```markdown
   ---
   name: ar:init
   description: Initialize agents-reverse configuration and integration
   argument-hint: "[--integration]"
   ---

   Initialize agents-reverse in this project.

   <execution>
   Run the agents-reverse init command:

   \`\`\`bash
   ar init $ARGUMENTS
   \`\`\`

   This creates:
   - \`.agents-reverse.yaml\` configuration file
   - With \`--integration\`: command files for detected AI assistants
   </execution>
   ```

2. `getOpenCodeTemplates(): IntegrationTemplate[]` - Returns templates for OpenCode:

   a. ar-generate.md:
   ```markdown
   ---
   description: Generate AI-friendly documentation for the entire codebase
   agent: build
   ---

   Generate comprehensive documentation for this codebase using agents-reverse.

   Run: \`ar generate $ARGUMENTS\`

   Arguments supported:
   - \`--budget N\` - Override token budget
   - \`--dry-run\` - Show plan without writing files
   - \`--verbose\` - Show detailed output
   ```

   b. ar-update.md (similar pattern)

3. `getHookTemplate(): string` - Returns the session-end hook JavaScript content:
   - Check AR_DISABLE_HOOK env var
   - Check config for hook_enabled: false
   - Check git status --porcelain, exit if empty
   - Spawn `ar update --quiet` detached with unref()
   - Use CommonJS (require) since hooks run via node directly

Use template literal strings with proper escaping for backticks.
  </action>
  <verify>
`npx tsc --noEmit` passes. Verify templates are valid:
```bash
npm run build && node -e "import('./dist/integration/templates.js').then(m => console.log(m.getClaudeTemplates().length, 'claude templates'))"
```
Should output "3 claude templates"
  </verify>
  <done>
- getClaudeTemplates() returns 3 templates (generate, update, init)
- getOpenCodeTemplates() returns 2 templates (generate, update)
- getHookTemplate() returns valid JavaScript hook code
  </done>
</task>

</tasks>

<verification>
All checks pass:
1. `npx tsc --noEmit` - No TypeScript errors
2. `npm run build` - Build succeeds
3. Environment detection works: `node -e "import('./dist/integration/detect.js').then(m => console.log(JSON.stringify(m.detectEnvironments('.'), null, 2)))"`
4. Templates generate: `node -e "import('./dist/integration/templates.js').then(m => console.log(m.getClaudeTemplates().map(t => t.filename)))"`
</verification>

<success_criteria>
- src/integration/types.ts exports DetectedEnvironment, IntegrationTemplate, EnvironmentType
- src/integration/detect.ts exports detectEnvironments function that finds .claude/ in this project
- src/integration/templates.ts exports getClaudeTemplates, getOpenCodeTemplates, getHookTemplate
- All files follow ESM patterns with .js imports
- No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-integration-commands/04-01-SUMMARY.md`
</output>
