---
phase: 01-foundation-discovery
plan: 03
type: execute
wave: 2
depends_on: ["01-02"]
files_modified:
  - src/discovery/filters/gitignore.ts
  - src/discovery/filters/binary.ts
  - src/discovery/filters/vendor.ts
  - src/discovery/filters/custom.ts
  - src/discovery/filters/index.ts
autonomous: true

must_haves:
  truths:
    - "Gitignore filter excludes files matching .gitignore patterns"
    - "Binary filter excludes known binary extensions"
    - "Binary filter falls back to content analysis for unknown extensions"
    - "Vendor filter excludes node_modules, .git, etc by default"
    - "Custom filter excludes patterns from user config"
  artifacts:
    - path: "src/discovery/filters/gitignore.ts"
      provides: "Gitignore pattern filter"
      exports: ["createGitignoreFilter"]
    - path: "src/discovery/filters/binary.ts"
      provides: "Binary file filter"
      exports: ["createBinaryFilter"]
    - path: "src/discovery/filters/vendor.ts"
      provides: "Vendor directory filter"
      exports: ["createVendorFilter"]
    - path: "src/discovery/filters/custom.ts"
      provides: "Custom pattern filter"
      exports: ["createCustomFilter"]
    - path: "src/discovery/filters/index.ts"
      provides: "Filter chain orchestration"
      exports: ["applyFilters"]
  key_links:
    - from: "src/discovery/filters/gitignore.ts"
      to: "ignore"
      via: "import"
      pattern: "import.*ignore"
    - from: "src/discovery/filters/binary.ts"
      to: "isbinaryfile"
      via: "import"
      pattern: "import.*isbinaryfile"
---

<objective>
Implement all file filters that determine which files to include/exclude.

Purpose: This is the core logic for DISC-01 (gitignore), DISC-02 (binary), DISC-03 (vendor), and DISC-04 (custom patterns). Each filter implements the FileFilter interface and returns whether a file should be excluded.

Output: Four filter implementations plus an applyFilters function that runs files through the filter chain.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-discovery/01-CONTEXT.md
@.planning/phases/01-foundation-discovery/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gitignore and vendor filters</name>
  <files>src/discovery/filters/gitignore.ts, src/discovery/filters/vendor.ts</files>
  <action>
Create src/discovery/filters/gitignore.ts following RESEARCH.md Pattern 2:

Import ignore from 'ignore'.
Import { FileFilter } from '../types.js'.
Import path and fs/promises.

Export async function createGitignoreFilter(root: string): Promise<FileFilter>
- Load .gitignore from root if exists (silently skip if missing)
- Return object implementing FileFilter:
  - name: 'gitignore'
  - shouldExclude(absolutePath): Check path.relative(root, absolutePath) against ignore instance
  - CRITICAL: Use trailing slash for directories (append '/' when checking directories)
  - CRITICAL: Use relative paths only (no leading / or ./)
  - Handle case where path is outside root (return false, don't exclude)

Create src/discovery/filters/vendor.ts:

Import { FileFilter } from '../types.js'.
Import path.

Export function createVendorFilter(vendorDirs: string[]): FileFilter
- name: 'vendor'
- shouldExclude(absolutePath): Check if any path segment matches vendorDirs
- Example: '/project/node_modules/foo/bar.js' matches 'node_modules'
- Use path.sep to split and check each segment

Default vendorDirs from RESEARCH.md: node_modules, vendor, .git, dist, build, __pycache__, .next, venv, .venv, target
  </action>
  <verify>
`npm run build` succeeds.
Quick test: `npx tsx -e "import { createVendorFilter } from './src/discovery/filters/vendor.js'; const f = createVendorFilter(['node_modules']); console.log(f.shouldExclude('/foo/node_modules/bar.js'))"` outputs true.
  </verify>
  <done>
Gitignore filter loads .gitignore and checks patterns correctly. Vendor filter excludes files in vendor directories.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create binary and custom filters</name>
  <files>src/discovery/filters/binary.ts, src/discovery/filters/custom.ts</files>
  <action>
Create src/discovery/filters/binary.ts following RESEARCH.md Pattern 3:

Import { isBinaryFile } from 'isbinaryfile'.
Import { FileFilter } from '../types.js'.
Import path, fs/promises.

Define BINARY_EXTENSIONS Set from RESEARCH.md (images, archives, executables, media, fonts).

Export function createBinaryFilter(options: { maxFileSize?: number, additionalExtensions?: string[] }): FileFilter
- name: 'binary'
- shouldExclude async:
  1. Check extension first (fast path) - return true if in BINARY_EXTENSIONS
  2. Check file size against maxFileSize (default 1MB) - return true if too large (with logging later)
  3. Fall back to isBinaryFile(path) for content analysis
  4. Wrap in try/catch - if unreadable, return true (skip it)

Create src/discovery/filters/custom.ts:

Import ignore from 'ignore'.
Import { FileFilter } from '../types.js'.
Import path.

Export function createCustomFilter(patterns: string[], root: string): FileFilter
- name: 'custom'
- Use ignore library to check patterns
- Similar to gitignore filter but with user-provided patterns
- If patterns array is empty, shouldExclude always returns false
  </action>
  <verify>
`npm run build` succeeds.
Test binary: `npx tsx -e "import { createBinaryFilter } from './src/discovery/filters/binary.js'; const f = createBinaryFilter({}); console.log(f.shouldExclude('/foo/image.png'))"` outputs true.
  </verify>
  <done>
Binary filter excludes known extensions and uses content analysis for unknown. Custom filter excludes user patterns.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create filter chain orchestrator</name>
  <files>src/discovery/filters/index.ts</files>
  <action>
Create src/discovery/filters/index.ts:

Import { FileFilter, FilterResult } from '../types.js'.
Re-export all filter creators from sub-modules.

Export async function applyFilters(
  files: string[],
  filters: FileFilter[]
): Promise<FilterResult>

Implementation:
- Iterate through each file
- For each file, run through filters in order
- Stop at first filter that excludes (short-circuit)
- Record which filter excluded which file
- Return { included: [...], excluded: [...] }

This is the Filter Chain Pattern from RESEARCH.md.

Also export a convenience function:
Export async function createDefaultFilters(
  root: string,
  config: { vendorDirs: string[], patterns: string[], maxFileSize: number }
): Promise<FileFilter[]>
- Creates gitignore, vendor, binary, custom filters in standard order
- Returns array ready for applyFilters
  </action>
  <verify>
`npm run build` succeeds.
Integration test:
`npx tsx -e "
import { createVendorFilter } from './src/discovery/filters/vendor.js';
import { applyFilters } from './src/discovery/filters/index.js';
const f = createVendorFilter(['node_modules']);
applyFilters(['/a/b.js', '/a/node_modules/c.js'], [f]).then(r => {
  console.log('included:', r.included.length);
  console.log('excluded:', r.excluded.length);
});
"` outputs included: 1, excluded: 1.
  </verify>
  <done>
Filter chain runs files through all filters, records exclusion reasons, returns split lists.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. Gitignore filter respects .gitignore patterns (test with actual .gitignore file)
3. Vendor filter excludes node_modules paths
4. Binary filter excludes .png, .jpg, .exe files by extension
5. applyFilters correctly categorizes files and reports which filter excluded each
</verification>

<success_criteria>
- DISC-01: Gitignore patterns respected via ignore library
- DISC-02: Binary files excluded (extension-first, content-fallback)
- DISC-03: Vendor directories excluded by default
- DISC-04: Custom patterns from config respected
- Filter chain reports exclusion reasons for debugging
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-discovery/01-03-SUMMARY.md`
</output>
